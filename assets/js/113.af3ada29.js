(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{436:function(e,s,_){"use strict";_.r(s);var v=_(8),r=Object(v.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁"}},[e._v("#")]),e._v(" Redis分布式锁")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://www.jianshu.com/p/edca1528dcc3",target:"_blank",rel:"noopener noreferrer"}},[e._v("一文彻底弄清楚分布式锁"),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"_1-redis分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis分布式锁"}},[e._v("#")]),e._v(" 1 Redis分布式锁")]),e._v(" "),s("p",[s("strong",[e._v("原理")]),e._v("：多个服务，同一时刻内请求同一个共享资源，为防止关键业务出现数据冲突和并发错误，需要加分布式锁。")]),e._v(" "),s("p",[s("strong",[e._v("实现")]),e._v("："),s("code",[e._v("set <key> <value> [EX seconds] [PX milliseconds] [NX|XX]")]),e._v("，如果key不存在就设置键值对并带有过期时间，如果存在就设置失败。")]),e._v(" "),s("p",[s("strong",[e._v("注意点")]),e._v("：")]),e._v(" "),s("ol",[s("li",[e._v("设置Key的同时要设置过期时间，防止服务突然宕机，后续锁无法释放。设置key和过期时间的过程要保证原子性。")]),e._v(" "),s("li",[e._v("如果业务A执行的时间太长，锁已经过期了，此时其他线程获取了锁。当业务A执行完毕，此时将释放其他线程的锁，这将导致一系列问题。所以在释放锁的时候要通过Value判断是不是自己加的锁。（所以，value的选择要唯一，保证每一个服务线程的值是唯一的）")]),e._v(" "),s("li",[e._v("需要保证判断”是不是自己的锁“和”释放锁“的过程是原子性的，最常用的方法是写LUA脚本，也可以通过Redis的事务实现。")])]),e._v(" "),s("p",[s("strong",[e._v("其他高级问题")]),e._v("：")]),e._v(" "),s("ol",[s("li",[e._v("缓存续命：当分布式锁快要到期，业务还没有执行完的时候，需要给锁续命。")]),e._v(" "),s("li",[e._v("Redis集群可能出现的问题，异步复制会造成锁丢失：主节点刚刚告诉线程加锁成功，还没来得及把这个数据复制给从节点就挂了。")])]),e._v(" "),s("h2",{attrs:{id:"_2-redis和zookeeper分布式锁的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis和zookeeper分布式锁的区别"}},[e._v("#")]),e._v(" 2 Redis和Zookeeper分布式锁的区别")]),e._v(" "),s("p",[e._v("单机下：")]),e._v(" "),s("ul",[s("li",[e._v("redis 分布式锁，其实"),s("strong",[e._v("需要自己不断去尝试获取锁")]),e._v("，比较消耗性能。")]),e._v(" "),s("li",[e._v("zk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。")])]),e._v(" "),s("p",[e._v("如果是 Redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。")]),e._v(" "),s("p",[e._v("集群下：")]),e._v(" "),s("ul",[s("li",[e._v("redis 集群保证了 AP：先通知线程加锁成功，再将数据复制给从节点。")]),e._v(" "),s("li",[e._v("zk 集群保证了 CP：先将数据复制给从节点，全部复制完毕后再告诉线程加锁成功，虽然安全，但效率低。")])]),e._v(" "),s("h2",{attrs:{id:"_3-redission"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-redission"}},[e._v("#")]),e._v(" 3 Redission")]),e._v(" "),s("p",[e._v("RedLock的实现，用于实现分布式锁，可以方便解决分布式锁的各类问题。")]),e._v(" "),s("p",[e._v("使用多个 Redis 节点，每个 Redis 节点都是独立的、不同的。想要加锁成功就必须获得超过一半以上的节点。")])])}),[],!1,null,null,null);s.default=r.exports}}]);