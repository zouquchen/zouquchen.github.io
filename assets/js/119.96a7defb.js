(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{497:function(a,t,e){"use strict";e.r(t);var r=e(8),s=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"kafka-学习"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka-学习"}},[a._v("#")]),a._v(" Kafka 学习")]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("学习中")])]),a._v(" "),t("h2",{attrs:{id:"kafka概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka概念"}},[a._v("#")]),a._v(" Kafka概念")]),a._v(" "),t("p",[a._v("Kafka 传统定义：是一个"),t("strong",[a._v("分布式")]),a._v("的基于"),t("strong",[a._v("发布/订阅模式")]),a._v("的"),t("strong",[a._v("消息队列")]),a._v("，主要应用于大数据实时处理领域。")]),a._v(" "),t("p",[a._v("kafka 最新定义：开源的"),t("strong",[a._v("分布式事件流平台")]),a._v("，用于高性能"),t("strong",[a._v("数据管道 、流分析、数据集成和关键任务")]),a._v("应用。")]),a._v(" "),t("blockquote",[t("p",[a._v("野心非常大，不甘心只做消息队列")])]),a._v(" "),t("p",[a._v("发布/订阅：消息的发布者不会将消息直接发送给特定的订阅者，而是"),t("strong",[a._v("将发布的消息分为不同的类别")]),a._v("，订阅者"),t("strong",[a._v("只接收感兴趣的消息")]),a._v("。")]),a._v(" "),t("p",[a._v("在大数据库场景主要采用 KafKa，JavaEE 开发中采用 ActiveMQ、RabbitMQ、RocketMQ")]),a._v(" "),t("p",[a._v("⭐ 消息队列作用：削峰、异步、解耦")]),a._v(" "),t("p",[a._v("⭐ 消息队列模式")]),a._v(" "),t("ul",[t("li",[a._v("点对点模式：消费者主动拉取数据，消息成功消费后清除消息")]),a._v(" "),t("li",[a._v("发布/订阅模式：可以有多个 topic 主题，每个消费者相互独立，消费者消费数据后不删除数据")])]),a._v(" "),t("h2",{attrs:{id:"kafka-基础架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka-基础架构"}},[a._v("#")]),a._v(" Kafka 基础架构")]),a._v(" "),t("ol",[t("li",[a._v("为方便扩展，提高吞吐量，一个 topic 分为多个 partition")]),a._v(" "),t("li",[a._v("配合分区的设计，提出消费者组的概念，组内每个消费者并行消费\n"),t("ul",[t("li",[a._v("一个分区 partition，只能由一个消费者消费。如果由多个消费者不利于消息的管理")])])]),a._v(" "),t("li",[a._v("为提高可用性，为每个 partition  增加若干副本\n"),t("ul",[t("li",[a._v("分为 leader & follower，只针对于 leader 进行生产和消费")]),a._v(" "),t("li",[a._v("只有 leader 挂掉后 follower 才能成为 leader，才能进行生产和消费")])])]),a._v(" "),t("li",[a._v("Zookeeper 管理 Kafka 集群\n"),t("ul",[t("li",[a._v("记录在线的 broker")]),a._v(" "),t("li",[a._v("记录 partitions 中的 leader")])])])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs2022/Kafka-architecture.png",alt:"Kafka"}})]),a._v(" "),t("ul",[t("li",[a._v("Producer：生产者，负责将客户端生产的消息发送到 Kafka 中，可以支持消息的异步发送和批量发送；")]),a._v(" "),t("li",[a._v("broker：服务代理节点，Kafka 集群中的一台服务器就是一个 broker，可以水平无限扩展，同一个 Topic 的消息可以分布在多个 broker 中；")]),a._v(" "),t("li",[a._v("Consumer：消费者，通过连接到 Kafka 上来接收消息，用于相应的业务逻辑处理。\nZooKeeper：管理 Kafka 集群")]),a._v(" "),t("li",[a._v("Consumer Group：消费者组，指的是多个消费者共同组成一个组来消费一个 Topic 中的消息。")])]),a._v(" "),t("h2",{attrs:{id:"kafka-重要概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka-重要概念"}},[a._v("#")]),a._v(" Kafka 重要概念")]),a._v(" "),t("h3",{attrs:{id:"topic-与-partition"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#topic-与-partition"}},[a._v("#")]),a._v(" Topic 与 Partition")]),a._v(" "),t("p",[a._v("一个 Topic 是一个逻辑上的消息分类，可以看作是一个消息的容器。生产者将消息发布到特定的 Topic 中，而消费者则从 Topic 中订阅并消费消息。")]),a._v(" "),t("p",[a._v("每个 Topic 可以被分成多个 Partition，每个 Partition 是一个有序的消息序列。Partition 在物理上是分布在不同的 Broker 节点上的，这样可以实现消息的分布式存储和处理。")]),a._v(" "),t("p",[a._v("Partition 的数量是在创建 Topic 时指定的，可以根据需求进行设置。每个 Partition 都有一个唯一的标识符（Partition ID），通常是一个整数。")]),a._v(" "),t("p",[a._v("Partition的存在有以下几个重要的作用：")]),a._v(" "),t("ol",[t("li",[a._v("提供了消息的并行处理能力：不同的 Partition 可以在不同的 Broker 节点上并行处理消息，提高了整体的吞吐量。")]),a._v(" "),t("li",[a._v("实现了消息的顺序性：每个 Partition 内的消息是有序的，但不同 Partition 之间的消息顺序是不保证的。")]),a._v(" "),t("li",[a._v("提供了消息的冗余和容错能力：每个 Partition 都有多个副本（Replica），分布在不同的 Broker 节点上，当某个 Broker 节点故障时，其他节点上的副本可以继续提供服务。")])]),a._v(" "),t("p",[a._v("在消费者消费消息时，可以选择订阅整个 Topic，也可以选择订阅特定的 Partition。\nTopic 是消息的逻辑分类，而 Partition 是 Topic 的物理分片，提供了并行处理、顺序性和容错能力。通过合理的设置 Partition 数量和消费者的订阅方式，可以实现高效的消息处理和分布式的消息传递。")]),a._v(" "),t("p",[a._v("由于一个分区只属于一个主题，很多时候也会被叫做主题分区(Topic-Partition)。")]),a._v(" "),t("h3",{attrs:{id:"leader-和-follower"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#leader-和-follower"}},[a._v("#")]),a._v(" Leader 和 Follower")]),a._v(" "),t("p",[a._v("一个分区会有多个副本，副本之间是一主(Leader)多从(Follower)的关系，Leader 对外提供服务，这里的对外指的是与客户端程序进行交互，而 Follower 只是被动地同步 Leader 而已，不能与外界进行交互。")]),a._v(" "),t("p",[a._v("当然了，你可能知道在很多其他系统中 Follower 是可以对外提供服务的，比如 MySQL 的从库是可以处理读操作的，但是在 Kafka 中 Follower 只负责消息同步，不会对外提供服务。")]),a._v(" "),t("h3",{attrs:{id:"kafka-多副本机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka-多副本机制"}},[a._v("#")]),a._v(" Kafka 多副本机制")]),a._v(" "),t("p",[a._v("Kafka 为分区引入了多副本机制，同一分区的不同副本中保存的信息是相同的，通过多副本机制实现了故障的自动转移，当集群中某个 broker 失效时仍然能保证服务可用，可以提升容灾能力。")]),a._v(" "),t("p",[a._v("副本处于不同 broker 中，生产者与消费者只和 Leader 副本进行交互，而 Follower 副本只负责消息的同步。当 Leader 副本出现故障时，会从 Follower 副本中重新选举新的 Leader 副本对外提供服务。")]),a._v(" "),t("ul",[t("li",[a._v("AR(Assigned Replicas)：一个分区中的所有副本统称为 AR；")]),a._v(" "),t("li",[a._v("ISR(In-Sync Replicas)：Leader 副本和所有保持一定程度同步的 Follower 副本（包括 Leader 本身）组成 ISR；")]),a._v(" "),t("li",[a._v("OSR(Out-of-Sync Raplicas)：与 ISR 相反，没有与 Leader 副本保持一定程度同步的所有Follower 副本组成OSR；")])]),a._v(" "),t("blockquote",[t("p",[a._v("AR = ISR + OSR")])]),a._v(" "),t("p",[a._v("生产者会将消息发送给 Leader 副本，然后 Follower 副本才能从 Leader 中拉取消息进行同步，在同一时刻，所有副本中的消息不完全相同，\n也就是说同步期间，Follower 相对于 Leader 而言会有一定程度上的滞后，当然这个滞后程度是可以通过参数来配置的。")]),a._v(" "),t("p",[a._v("Leader 负责维护和跟踪 ISR 集合中所有 Follower 副本的滞后状态，当 Follower 出现滞后太多或者失效时，Leader 将会把它从 ISR 集合中剔除。")]),a._v(" "),t("p",[a._v("当然，如果 OSR 集合中有 Follower 同步范围追上了 Leader，那么 Leader 也会把它从 OSR 集合中转移至 ISR 集合。")]),a._v(" "),t("p",[a._v("一般情况下，当 Leader 发送故障或失效时，只有 ISR 集合中的 Follower 才有资格被选举为新的 Leader，而 OSR 集合中的 Follower 则没有这个机会（不过可以修改参数配置来改变）。")]),a._v(" "),t("h2",{attrs:{id:"安装使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装使用"}},[a._v("#")]),a._v(" 安装使用")]),a._v(" "),t("h3",{attrs:{id:"安装部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装部署"}},[a._v("#")]),a._v(" 安装部署")]),a._v(" "),t("h4",{attrs:{id:"集群规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群规划"}},[a._v("#")]),a._v(" 集群规划")]),a._v(" "),t("p",[a._v("我的虚拟机里面由 3 个 CentOS 系统，所以规划为：")]),a._v(" "),t("table",[t("thead",[t("tr",[t("th",[a._v("101")]),a._v(" "),t("th",[a._v("102")]),a._v(" "),t("th",[a._v("103")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("zk")]),a._v(" "),t("td",[a._v("zk")]),a._v(" "),t("td",[a._v("zk")])]),a._v(" "),t("tr",[t("td",[a._v("kafka")]),a._v(" "),t("td",[a._v("kafka")]),a._v(" "),t("td",[a._v("kafka")])])])]),a._v(" "),t("p",[a._v("每一台机器内都安装 zookeeper 和 kafka，我这里为了方便就只在 103 内配置了 zk。")]),a._v(" "),t("h4",{attrs:{id:"集群部署"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群部署"}},[a._v("#")]),a._v(" 集群部署")]),a._v(" "),t("p",[t("strong",[a._v("步骤0")]),a._v("：配置 zk 集群，也可以单机")]),a._v(" "),t("p",[t("strong",[a._v("步骤1")]),a._v("："),t("a",{attrs:{href:"https://kafka.apache.org/downloads",target:"_blank",rel:"noopener noreferrer"}},[a._v("下载"),t("OutboundLink")],1)]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs2022/kafka-download.png",alt:"image-20220925095359505"}})]),a._v(" "),t("p",[a._v("2.12 版本指 Scale 版本，3.0.0 版本指 Kafka 版本。")]),a._v(" "),t("p",[t("strong",[a._v("步骤2")]),a._v("：解压 "),t("code",[a._v("tar -zxvf kafka_2.12-3.0.0.tgz")])]),a._v(" "),t("p",[t("strong",[a._v("步骤3")]),a._v("：重命名 "),t("code",[a._v("mv kafka_2.12-3.0.0 kafka")]),a._v("，把解压后的文件名改为 kafka")]),a._v(" "),t("p",[t("strong",[a._v("步骤4")]),a._v("：配置 "),t("code",[a._v("kafka/config/server.properties")])]),a._v(" "),t("div",{staticClass:"language-properties line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-properties"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# kafka 集群中身份唯一表示，三个 broker 分别配置 0 1 2")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("broker.id")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("0")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 存储 kafka 数据，默认放在 temp 中，会被定期清理")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("log.dirs")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("/opt/kafka/datas")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 配置 zk 集群，/kafka 表示都在 kafka 节点上，后面需要找个集群时可以直接删掉")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# zookeeper.connect=192.168.150.101:2181,192.168.150.102:2181,192.168.150.103:2181/kafka")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 也可以不使用集群，就配置个单机")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("zookeeper.connect")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("192.168.150.103:2181/kafka")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("p",[a._v("分别配置 3 个 kafka，注意 broker.id 要不同。")]),a._v(" "),t("p",[t("strong",[a._v("步骤5")]),a._v("：配置环境变量")]),a._v(" "),t("p",[t("code",[a._v("vim /etc/profile.d/my_env.sh")])]),a._v(" "),t("p",[a._v("为每个节点，添加以下内容：")]),a._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#KAFKA_HOME")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("export")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("KAFKA_HOME")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/opt/kafka\n"),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("export")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t("span",{pre:!0,attrs:{class:"token environment constant"}},[a._v("PATH")])]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token environment constant"}},[a._v("$PATH")]),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token variable"}},[a._v("$KAFKA_HOME")]),a._v("/bin\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("p",[a._v("刷新："),t("code",[a._v("source /etc/profile")])]),a._v(" "),t("p",[t("strong",[a._v("步骤6")]),a._v("：启动 zookeeper")]),a._v(" "),t("p",[t("strong",[a._v("步骤7")]),a._v("：启动 kafka")]),a._v(" "),t("p",[t("code",[a._v("kafka-server-start.sh -daemon config/server.properties")])]),a._v(" "),t("h2",{attrs:{id:"流处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流处理"}},[a._v("#")]),a._v(" 流处理")]),a._v(" "),t("h3",{attrs:{id:"流处理与普通业务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流处理与普通业务"}},[a._v("#")]),a._v(" 流处理与普通业务")]),a._v(" "),t("p",[a._v('流处理之所以被称为"流"，是因为它处理的是连续不断的数据流，而不是离散的、静态的数据集合。')]),a._v(" "),t("p",[a._v("与传统的批处理不同，流处理是实时处理数据流的一种方式。它可以在数据到达时立即进行处理，并持续地对数据进行处理和响应。流处理框架可以处理无限的数据流，而不需要等待所有数据都到达才开始处理。")]),a._v(" "),t("p",[a._v("与普通的处理业务相比，流处理具有以下几个不同之处：")]),a._v(" "),t("ul",[t("li",[a._v("实时性：流处理是实时处理数据流的方式，可以在数据到达时立即进行处理。这使得流处理能够及时响应数据的变化和事件的发生，适用于需要实时性的应用场景。")]),a._v(" "),t("li",[a._v("连续性：流处理是对连续的数据流进行处理，而不是对离散的数据集合进行处理。它可以处理无限的数据流，并持续地对数据进行处理和分析。")]),a._v(" "),t("li",[a._v("有状态性：流处理框架可以维护和更新状态信息，以支持更复杂的数据处理逻辑。这意味着流处理可以跟踪和记忆之前处理过的数据，从而实现更丰富的计算和分析。")]),a._v(" "),t("li",[a._v("灵活性：流处理框架通常提供了丰富的API和功能，可以进行各种数据转换、聚合、过滤等操作。它们还支持窗口操作、时间窗口计算等高级功能，使得开发者可以根据需求进行灵活的数据处理。")])]),a._v(" "),t("h3",{attrs:{id:"kafka在流处理中的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kafka在流处理中的作用"}},[a._v("#")]),a._v(" Kafka在流处理中的作用")]),a._v(" "),t("p",[a._v("Kafka在流处理中的地位主要体现在以下几个方面：")]),a._v(" "),t("ul",[t("li",[a._v("数据源：作为数据源，可以提供实时的、连续的数据流。流处理框架可以从Kafka中订阅数据流，并对数据进行处理和分析。")]),a._v(" "),t("li",[a._v("数据存储：作为数据存储，可以将处理后的数据持久化存储在Kafka主题中。这些数据可以被其他应用程序或服务订阅和使用。")]),a._v(" "),t("li",[a._v("数据传递：作为消息队列系统，可以实现高效的数据传递和分发。流处理框架可以利用Kafka的分布式消息传递能力，将数据流分发到多个消费者节点上进行处理。")]),a._v(" "),t("li",[a._v("数据处理：Kafka Streams 是一个直接集成在 Kafka 客户端中的流处理库，可以在消费者端进行流处理。它提供了丰富的API和功能，如窗口操作、聚合、过滤、连接等，可以方便地进行实时数据处理。")]),a._v(" "),t("li",[a._v("数据一致性：提供了 Exactly-once 语义的支持，确保每条消息在处理过程中只会被处理一次，避免了重复处理和数据丢失的问题。")])]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("参考")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/weixin_43958974/article/details/122591425",target:"_blank",rel:"noopener noreferrer"}},[a._v("一文带你搞懂 Kafka 的系统架构"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=s.exports}}]);