(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{455:function(_,t,v){"use strict";v.r(t);var a=v(8),s=Object(a.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"高可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高可用"}},[_._v("#")]),_._v(" 高可用")]),_._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[_._v("Todo")])]),_._v(" "),t("h2",{attrs:{id:"_1-服务雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务雪崩"}},[_._v("#")]),_._v(" 1. 服务雪崩")]),_._v(" "),t("p",[_._v('多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务 C，微服务 B 和微服务 C 又调用其它的微服务，这就是所谓的"扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。')]),_._v(" "),t("h2",{attrs:{id:"_2-服务降级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务降级"}},[_._v("#")]),_._v(" 2. 服务降级")]),_._v(" "),t("p",[_._v("服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示。")]),_._v(" "),t("p",[_._v("哪些情况会触发降级")]),_._v(" "),t("ul",[t("li",[_._v("程序运行异常")]),_._v(" "),t("li",[_._v("超时")]),_._v(" "),t("li",[_._v("服务熔断触发服务降级")]),_._v(" "),t("li",[_._v("线程池/信号量打满导致服务降级")])]),_._v(" "),t("h2",{attrs:{id:"_3-服务熔断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-服务熔断"}},[_._v("#")]),_._v(" 3. 服务熔断")]),_._v(" "),t("p",[_._v("类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示。")]),_._v(" "),t("p",[_._v("就是保险丝，服务的降级->进而熔断->恢复调用链路。")]),_._v(" "),t("p",[_._v("熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。")]),_._v(" "),t("h2",{attrs:{id:"_4-服务限流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-服务限流"}},[_._v("#")]),_._v(" 4. 服务限流")]),_._v(" "),t("p",[_._v("秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行")]),_._v(" "),t("h2",{attrs:{id:"_5-sentinel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-sentinel"}},[_._v("#")]),_._v(" 5. Sentinel")]),_._v(" "),t("p",[_._v("分布式系统的流量防卫兵，Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。")]),_._v(" "),t("p",[_._v("流量控制（flow control），其原理是监控应用流量的 "),t("strong",[_._v("QPS")]),_._v(" 或"),t("strong",[_._v("并发线程数")]),_._v("等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。")]),_._v(" "),t("ul",[t("li",[_._v("阈值类型/单机阈值\n"),t("ul",[t("li",[_._v("QPS (每秒钟的请求数量)：当调用该api的QPS达到阈值的时候，进行限流。")]),_._v(" "),t("li",[_._v("线程数：当调用该api的线程数达到阈值的时候，进行限流。")])])]),_._v(" "),t("li",[_._v("流控模式\n"),t("ul",[t("li",[_._v("直接：api达到限流条件时，直接限流。")]),_._v(" "),t("li",[_._v("关联：当关联的资源达到阈值时，就限流自己。")]),_._v(" "),t("li",[_._v("链路：只记录指定链路上的流量(指定资源从入口资源进来的流量,如果达到阈值，就进行限流) [api级别的针对来源]")])])]),_._v(" "),t("li",[_._v("流控效果\n"),t("ul",[t("li",[_._v("快速失败：直接失败，抛异常。")]),_._v(" "),t("li",[_._v("Warm Up：根据 codeFactor (冷加载因子,默认3)的值，从阈值 codeFactor，经过预热时长，才达到设置的QPS阈值。")]),_._v(" "),t("li",[_._v("排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效。")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);