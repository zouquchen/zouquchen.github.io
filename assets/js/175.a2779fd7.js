(window.webpackJsonp=window.webpackJsonp||[]).push([[175],{496:function(t,n,e){"use strict";e.r(n);var r=e(8),s=Object(r.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"控制反转与依赖注入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#控制反转与依赖注入"}},[t._v("#")]),t._v(" 控制反转与依赖注入")]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("前言")]),t._v(" "),n("p",[t._v("翻译来自Martin Fowler大师的 "),n("a",{attrs:{href:"https://www.martinfowler.com/articles/injection.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Inversion of Control Containers and the Dependency Injection pattern"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("在Java社区中，出现了许多轻量级容器，它们帮助将来自不同项目的组件组装成一个协调的应用程序。这些容器的底层都采用了一种常见的模式来执行连接，这个概念被称为“"),n("strong",[t._v("控制反转")]),t._v("”。在本文中，我将深入探讨这个模式的工作原理，更具体地称为“"),n("strong",[t._v("依赖注入")]),t._v("”，并将其与服务定位器进行对比。选择哪种方式并不重要，重要的是"),n("strong",[t._v("将配置与使用分离的原则")]),t._v("。")]),t._v(" "),n("p",[t._v("一个常见的问题是如何将不同的元素连接在一起：当这些元素是由不同团队构建且彼此了解有限时，如何将这个Web控制器架构与那个数据库接口连接在一起。许多框架已经尝试解决这个问题，并且有几个框架正在扩展提供一种从不同层面组装组件的通用能力。这些通常被称为轻量级容器，例如PicoContainer和Spring。")]),t._v(" "),n("p",[t._v("这些容器的基础是一些有趣的设计原则，这些原则超越了这些具体的容器，甚至超越了Java平台。在这里，我想开始探索其中一些原则。")]),t._v(" "),n("h2",{attrs:{id:"components-and-services"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#components-and-services"}},[t._v("#")]),t._v(" Components and Services")]),t._v(" "),n("p",[t._v('将元素连接在一起的话题几乎立即引入了围绕"服务"和"组件"这两个术语的混乱术语问题。你会很容易地找到关于这些事物定义的长篇矛盾文章。对于我在这里的目的，以下是我目前对这些多义词的使用方式。')]),t._v(" "),n("p",[t._v("组件是软件的一部分，它的源码不可以被使用者修改，只能扩展。")])])}),[],!1,null,null,null);n.default=s.exports}}]);