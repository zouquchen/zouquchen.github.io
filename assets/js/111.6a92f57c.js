(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{433:function(e,_,t){"use strict";t.r(_);var v=t(8),s=Object(v.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"过期删除策略和缓存淘汰机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#过期删除策略和缓存淘汰机制"}},[e._v("#")]),e._v(" 过期删除策略和缓存淘汰机制")]),e._v(" "),_("blockquote",[_("p",[e._v("如果不设置redis内存大小后设置最大内存为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。")]),e._v(" "),_("p",[e._v("一般推荐设置内存为最大物理内存的四分之三")])]),e._v(" "),_("h4",{attrs:{id:"_1-内存满了会怎么样"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-内存满了会怎么样"}},[e._v("#")]),e._v(" 1 内存满了会怎么样？")]),e._v(" "),_("p",[e._v("设置maxmemory为1，然后set一个字符串，之后会报OOM的错误。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/image-20220706205435284.png",alt:"image-20220706205435284"}})]),e._v(" "),_("h4",{attrs:{id:"_2-redis给缓存数据设置过期时间有啥用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis给缓存数据设置过期时间有啥用"}},[e._v("#")]),e._v(" 2 Redis给缓存数据设置过期时间有啥用？")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("因为内存是有限的，如果缓存中的所有数据都一直保存的话，很容易造成内存溢出的问题。")])]),e._v(" "),_("li",[_("p",[e._v("业务场景需要某个数据只在某一时间段内存在，比如短信验证码只能在1分钟内有效，用户登录的token只在1天内有效。")])])]),e._v(" "),_("h4",{attrs:{id:"_3-redis是如何判断数据是否过期的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-redis是如何判断数据是否过期的呢"}},[e._v("#")]),e._v(" 3 Redis是如何判断数据是否过期的呢？")]),e._v(" "),_("p",[e._v("Redis通过一个叫过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个键，过期字典的值是一个long long类型的整数，保存了key所指向的数据库的过期时间（时间戳）。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs/redis%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4.96c57f41.png",alt:"redis过期字典"}})]),e._v(" "),_("h4",{attrs:{id:"_4-过期数据的删除策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-过期数据的删除策略"}},[e._v("#")]),e._v(" 4 过期数据的删除策略？")]),e._v(" "),_("p",[e._v("策略：定期删除 + 惰性删除")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("定期删除：每隔一段时间，随机检查一部分已经过期的key，并将其删除。这个时间间隔由配置文件中的参数hz决定，默认为10秒。Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。")])]),e._v(" "),_("li",[_("p",[e._v("惰性删除：当客户端尝试访问一个已经过期的 key 时会立即将其删除。对CPU最友好，但是可能回造成太多过期 key 没有被删除，对内存不友好。（空间换时间）")])])]),e._v(" "),_("p",[e._v("这两种策略相结合，可以保证Redis能够高效地清理过期的key，同时又不会对性能造成太大的影响")]),e._v(" "),_("p",[e._v("但是，仅通过给 key 设置过期时间还是有问题的，因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况，这样就导致大量过期 key 堆积在内存中，然后就 OOM 了。使用 Redis 内存淘汰机制解决。")]),e._v(" "),_("h4",{attrs:{id:"_5-redis内存淘汰机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-redis内存淘汰机制"}},[e._v("#")]),e._v(" 5 Redis内存淘汰机制？")]),e._v(" "),_("p",[_("strong",[e._v("MySQL里有2000w数据，Redis中只有20w数据，如何保证Redis中的数据都是热点数据？")])]),e._v(" "),_("p",[e._v("Redis提供8种淘汰策略：")]),e._v(" "),_("ul",[_("li",[e._v("volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。")]),e._v(" "),_("li",[e._v("volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。")]),e._v(" "),_("li",[e._v("volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。")]),e._v(" "),_("li",[e._v("volatile-random：从已设置过去时间的数据集中任意选择数据淘汰。")]),e._v(" "),_("li",[e._v("allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最少使用的key。（"),_("strong",[e._v("常用")]),e._v("）")]),e._v(" "),_("li",[e._v("allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。")]),e._v(" "),_("li",[e._v("allkeys-random：当内存不足以容纳新写入数据时，从数据集中任意选择数据淘汰。")]),e._v(" "),_("li",[e._v("no-eviction：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。（"),_("strong",[e._v("默认")]),e._v("）")]),e._v(" "),_("li")]),e._v(" "),_("blockquote",[_("p",[e._v("lru: least recently used，最近最少使用，这种策略假设最近被访问的键值对在未来也可能被访问，\n因此将最近最少被访问的键值对淘汰，可以更好地保留常用的数据。")]),e._v(" "),_("p",[e._v("lfu: least frequently used，最近不经常使用，这种策略假设使用频率低的键值对在未来也可能很少被访问，\n因此将使用频率较低的键值对淘汰，可以更好地保留经常被访问的数据。")])]),e._v(" "),_("blockquote",[_("p",[e._v("总结：")]),e._v(" "),_("ul",[_("li",[e._v("2个维度：过期键中筛选（volatile）、所有键中筛选（allkey）")]),e._v(" "),_("li",[e._v("4个方面：LRU、LFU、random、ttl")])])]),e._v(" "),_("h4",{attrs:{id:"_6-删除策略与淘汰机制的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-删除策略与淘汰机制的区别"}},[e._v("#")]),e._v(" 6 删除策略与淘汰机制的区别")]),e._v(" "),_("p",[e._v("淘汰策略（Eviction Policy）是指在"),_("strong",[e._v("内存使用达到上限")]),e._v("时，根据一定的规则选择哪些key需要被淘汰（即删除）以释放内存空间。目的是为了保证Redis在内存不足时能够优先保留重要的数据，同时尽量减少对业务的影响。")]),e._v(" "),_("p",[e._v("删除策略（Deletion Policy）是指在删除 key 时采用的具体策略。删除策略的目的是为了及时清理过期的 key，以避免占用过多的内存空间。")]),e._v(" "),_("p",[e._v("总结来说，淘汰策略是在内存不足时选择哪些 key 需要被淘汰，而删除策略是在 key 过期时如何进行删除操作。淘汰策略是为了"),_("strong",[e._v("管理内存使用")]),e._v("，而删除策略是为了"),_("strong",[e._v("清理过期的 key")]),e._v("。")])])}),[],!1,null,null,null);_.default=s.exports}}]);