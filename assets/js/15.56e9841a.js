(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{338:function(t,a,v){"use strict";v.r(a);var _=v(8),s=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"java基本语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java基本语法"}},[t._v("#")]),t._v(" Java基本语法")]),t._v(" "),a("h2",{attrs:{id:"_1-基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本概念"}},[t._v("#")]),t._v(" 1 基本概念")]),t._v(" "),a("h3",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("对象")]),t._v("：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。")]),t._v(" "),a("li",[a("strong",[t._v("类")]),t._v("：类是一个模板，它描述一类对象的行为和状态。")]),t._v(" "),a("li",[a("strong",[t._v("方法")]),t._v("：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。")]),t._v(" "),a("li",[a("strong",[t._v("实例变量")]),t._v("：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。")])]),t._v(" "),a("h3",{attrs:{id:"创建对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建对象"}},[t._v("#")]),t._v(" 创建对象")]),t._v(" "),a("p",[t._v("对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("声明")]),t._v("：声明一个对象，包括对象名称和对象类型。")]),t._v(" "),a("li",[a("strong",[t._v("实例化")]),t._v("：使用关键字 new 来创建一个对象。")]),t._v(" "),a("li",[a("strong",[t._v("初始化")]),t._v("：使用 new 创建对象时，会调用构造方法初始化对象。")])]),t._v(" "),a("h3",{attrs:{id:"变量类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量类型"}},[t._v("#")]),t._v(" 变量类型")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("局部变量")]),t._v("：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。")]),t._v(" "),a("li",[a("strong",[t._v("成员变量")]),t._v("：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。")]),t._v(" "),a("li",[a("strong",[t._v("类变量")]),t._v("：类变量也声明在类中，方法体之外，但必须声明为 static 类型。")]),t._v(" "),a("li",[t._v("其他常用描述的变量：\n"),a("ul",[a("li",[t._v("循环控制变量：变量的值会随着程序执行的过程而改变。")])])])]),t._v(" "),a("h2",{attrs:{id:"_2-构造器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-构造器"}},[t._v("#")]),t._v(" 2 构造器")]),t._v(" "),a("p",[t._v("构造器的作用：完成类对象的初始化")]),t._v(" "),a("h3",{attrs:{id:"构造方法有哪些特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造方法有哪些特性"}},[t._v("#")]),t._v(" 构造方法有哪些特性？")]),t._v(" "),a("ul",[a("li",[t._v("名字与类名相同")]),t._v(" "),a("li",[t._v("没有返回值，但不能用void声明")]),t._v(" "),a("li",[t._v("生成类的对象时会自动执行，无需调用。")])]),t._v(" "),a("h3",{attrs:{id:"若一个类没有声明构造方法-该程序能正确执行吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#若一个类没有声明构造方法-该程序能正确执行吗"}},[t._v("#")]),t._v(" 若一个类没有声明构造方法，该程序能正确执行吗？")]),t._v(" "),a("p",[t._v("可以执行，因为一个类即使没有声明构造方法也会默认的带有无参构造器。如果开发者添加了类的构造器（无参或有参），Java不会再添加默认的无参构造器，这时候就不能直接new一个对象不传递参数了，所以我们一直在不知不觉地使用构造方法，这也就是为什么创建对象的时候后面要加一个括号（因为调用无参的构造器）。即使创建了有参构造器，也要写一个无参构造器，避免踩坑。")]),t._v(" "),a("h2",{attrs:{id:"_3-关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-关键字"}},[t._v("#")]),t._v(" 3 关键字")]),t._v(" "),a("h3",{attrs:{id:"transient"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transient"}},[t._v("#")]),t._v(" transient")]),t._v(" "),a("p",[t._v("对于不想序列化的变量使用transient关键字修饰。")]),t._v(" "),a("p",[t._v("阻止实例中那些用此关键字修饰的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。")])])}),[],!1,null,null,null);a.default=s.exports}}]);