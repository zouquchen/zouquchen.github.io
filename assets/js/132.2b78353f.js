(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{456:function(v,_,e){"use strict";e.r(_);var s=e(8),r=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"项目高并发介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#项目高并发介绍"}},[v._v("#")]),v._v(" 项目高并发介绍")]),v._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[v._v("草稿")])]),v._v(" "),_("h2",{attrs:{id:"mq-redis-并发方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mq-redis-并发方案"}},[v._v("#")]),v._v(" MQ + Redis 并发方案")]),v._v(" "),_("p",[_("strong",[v._v("两个微服务")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Order 微服务：从 Redis 中读取信息判断用户是否可以预约，当用户可以预约讲座时，将用户 id 和讲座 id 封装成一个对象发送到 MQ。")])]),v._v(" "),_("li",[_("p",[v._v("Lecture 微服务：监听 MQ，从 MQ 中获取用户 id 和讲座 id，将用户预约记录插入数据库并减少用户可预约讲座数量。同时更新 Redis 内的信息。")])])]),v._v(" "),_("p",[_("strong",[v._v("Redis")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("存储每一场讲座的开始预约时间，开始时间之后用户才可以预约。")]),v._v(" "),_("li",[v._v("存储每一场讲座的剩余可预约数量，当可预约数量为 0 时就不可预约了。")]),v._v(" "),_("li",[v._v("存储已预约记录，防止用户重复预约。")])]),v._v(" "),_("p",[_("strong",[v._v("MQ")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("存储用户 id + 讲座 id 封装成的对象，根据这信息，消费者服务就可以更新 MySQL 和 Redis。")])]),v._v(" "),_("p",[_("strong",[v._v("MySQL")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("Lecture表：存放讲座的相关信息，包括剩余可预约数量。")]),v._v(" "),_("li",[v._v("Order表：存放用于的预约记录（user Id 和 lecture Id 构成唯一索引）")])]),v._v(" "),_("p",[_("strong",[v._v("预约流程")]),v._v("：")]),v._v(" "),_("ol",[_("li",[v._v("前端发送预约请求 nginx 反向代理到 Order 微服务")]),v._v(" "),_("li",[v._v("开始业务处理流程：\n"),_("ol",[_("li",[v._v("判断用户是否登录")]),v._v(" "),_("li",[v._v("从 Redis 内查询讲座预约是否开始或结束")]),v._v(" "),_("li",[v._v("从 Redis 内查询该用户是否重复预订讲座")]),v._v(" "),_("li",[v._v("递减 Redis 内该讲座的剩余可预约数量")]),v._v(" "),_("li",[v._v("将用户 id 和讲座 id 封装，发送到 MQ")])])]),v._v(" "),_("li",[v._v("Lecture 微服务监听 MQ\n"),_("ol",[_("li",[v._v("发现 MQ 的队列中有消息就开始消费")]),v._v(" "),_("li",[v._v("开启事务")]),v._v(" "),_("li",[v._v("添加用户预约讲座记录")]),v._v(" "),_("li",[v._v("减少该讲座的剩余可预约数量")]),v._v(" "),_("li",[v._v("commit")])])])]),v._v(" "),_("h2",{attrs:{id:"改进"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#改进"}},[v._v("#")]),v._v(" 改进")]),v._v(" "),_("h3",{attrs:{id:"问题及改进方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题及改进方案"}},[v._v("#")]),v._v(" 问题及改进方案")]),v._v(" "),_("p",[v._v("🔶 "),_("strong",[v._v("问题1")]),v._v("：MQ 积压情况下，重复预约")]),v._v(" "),_("p",[v._v("问题：当用户第一次预约，封装有用户 id 和讲座 id 的消息在 MQ 中没有被消费时，此时该用户又多次预约，这些预约信息会同样堆积到 MQ 中，导致 MQ 中出现无用的消息。并且，随着用户每一次的预约，Redis 内保存的可预约数量也会减少。")]),v._v(" "),_("p",[v._v("解决：当用户将预约记录发送给 MQ 的时候可以在 Zookeeper 内创建一个节点，表示用户正在预约，下一次用户再次预约的时候发现这个节点的存在，就不会在往 MQ 中发送消息了。")]),v._v(" "),_("p",[v._v("🔶 "),_("strong",[v._v("问题2")]),v._v("：操作数据库失败，Redis 和 MySQL 数据不一致")]),v._v(" "),_("p",[v._v("问题：当 Lecture 微服务在操作数据库失败时，回滚事务后，需要将 Redis 内该讲座的剩余可预约数量 +1。因为在 Order 微服务内对该讲座可预约数量 -1，没有预约成功的时候要加回来。")]),v._v(" "),_("p",[v._v("🔶 "),_("strong",[v._v("问题3")]),v._v("：预约之后无法立刻知道预约情况")]),v._v(" "),_("p",[v._v("问题：消息发送到消息队列中了，正常情况可以预约成功，但是如果发生意外，Order 微服务也不知道是否预约成功。")]),v._v(" "),_("p",[v._v("解决：使用 Zookeeper 做分布式协调，Zookeeper 中的节点表示正在预约，当该节点存在的时候，前端界面就一直 Loading，当 Zookeeper 中该节点消失就说明可以再次刷新用户预约状态。")]),v._v(" "),_("h3",{attrs:{id:"其他改进"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其他改进"}},[v._v("#")]),v._v(" 其他改进")]),v._v(" "),_("p",[v._v("🔶 "),_("strong",[v._v("高并发读改进")])]),v._v(" "),_("p",[v._v("之前解决的高并发问题都是针对于预约，其他一些常用查询也可以缓存到 Redis 里，所有的查询请求都是从 Redis 内查询，当 Redis 内不存在时再去请求 MySQL。当写请求修改讲座信息时，需要先删除 Redis 缓存内的数据，再更新 MySQL，保证 Redis 和数据库的一致性。（JVM 内部队列，保证更新数据或当获取 Redis 中不存在数据时会按队列内部串行执行）")]),v._v(" "),_("p",[v._v("🔶 "),_("strong",[v._v("静态资源缓存")])]),v._v(" "),_("p",[v._v("预约开始之前会存大量的刷新请求页面资源。")]),v._v(" "),_("p",[v._v("页面资源访问多：需要考虑静态化，CDN，静态资源缓存及压缩")]),v._v(" "),_("p",[v._v("🔶 "),_("strong",[v._v("接口限流")])]),v._v(" "),_("ul",[_("li",[v._v("前端限流：隐藏、disable 按钮等方法")]),v._v(" "),_("li",[v._v("同一个用户 10s 内只能请求预约操作一次，通过 redis 键过期策略，"),_("code",[v._v("order:userId:lectuerId")])]),v._v(" "),_("li",[v._v("令牌桶算法，令牌桶算法的基本思路是每个请求尝试获取一个令牌，后端只处理持有令牌的请求，生产令牌的速度和效率我们都可以自己限定。")])]),v._v(" "),_("p",[v._v("🔶 "),_("strong",[v._v("服务降级")])]),v._v(" "),_("p",[v._v("当服务某个服务器出现宕机或服务不可用时，可以使用 Hystrix 进行熔断和降级，给用户一个友好的提示。")]),v._v(" "),_("h3",{attrs:{id:"高并发进一步解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高并发进一步解决"}},[v._v("#")]),v._v(" 高并发进一步解决")]),v._v(" "),_("p",[v._v("系统拆分：将服务进一步拆分，每个服务到单独操作一类数据库。原本一个服务对应一个数据库，就变成了 n 个服务对应 n 个数据库，提高了并发量。")]),v._v(" "),_("p",[v._v("分库分表：一个数据库拆分成多个数据库，多个库分担压力；一个表拆分为多个表，提高 sql 语句性能。")]),v._v(" "),_("p",[v._v("读写分离：数据库搞主从架构，主库写入，从库读取，实现读取分离。")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/chendezhen/p/16409451.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("秒杀系统设计攻略"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=r.exports}}]);