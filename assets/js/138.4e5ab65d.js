(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{460:function(t,a,s){"use strict";s.r(a);var r=s(8),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"cqrs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cqrs"}},[t._v("#")]),t._v(" CQRS")]),t._v(" "),a("h2",{attrs:{id:"命令查询分离-cqs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令查询分离-cqs"}},[t._v("#")]),t._v(" 命令查询分离 CQS")]),t._v(" "),a("p",[t._v("CQRS 的内容基于 CQS 设计模式")]),t._v(" "),a("p",[t._v("命令查询分离（Command Query and Segregation, CQS）的核心思想是任何一个对象的方法可以划分为两类：")]),t._v(" "),a("ul",[a("li",[t._v("查询 Query：获取数据，返回查询数据，但不改变数据状态")]),t._v(" "),a("li",[t._v("命令 Command：改变数据状态，不返回任何数据")])]),t._v(" "),a("p",[t._v("根据 CQS，一个方法永远不应该同时存在。比如看栈的典型数据结构，push函数是一个命令，而top是一个查询。最后，pop 函数违反了 CQS 模式，因为它修改了堆栈的内部状态并同时返回信息。")]),t._v(" "),a("p",[t._v("因此，CQS 的核心是在单个对象上分离写入和读取。当代码要并行执行时：由于没有副作用，查询可以并行化而没有任何问题，但命令不能。")]),t._v(" "),a("h2",{attrs:{id:"cqrs-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cqrs-2"}},[t._v("#")]),t._v(" CQRS")]),t._v(" "),a("p",[t._v("Command and Query Responsibility Segregation，即命令查询职责分离，由Greg Young提出 。CQRS 在 CQS 基础之上，将分离的级别从代码方法级别扩展到对象级别。")]),t._v(" "),a("p",[t._v("CQRS 最大优势就是基于这种职责分离能带给我们更多的架构属性选择。")]),t._v(" "),a("ul",[a("li",[t._v("“查询” 和 “命令” 两侧进行独立部署以获取更好的伸缩性")]),t._v(" "),a("li",[t._v("“查询” 和 “命令” 两侧独立架构设计")]),t._v(" "),a("li",[t._v("“查询” 和 “命令”两侧进行独立数据模型设计")])]),t._v(" "),a("p",[t._v("团队引入CQRS模式之后，往往不仅仅是简单的在类的职责层面对读写进行分离，一般会采用更为复杂的应用架构风格，如下是典型的CQRS架构风格：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/zouquchen/Images/main/imgs2023/08/58ee3d6d55fbb2fbecffbdb05d4a85af4723dc4c.png",alt:"img"}})]),t._v(" "),a("ul",[a("li",[t._v("命令侧：命令侧引入命令总线以支持对不同命令的灵活路由；突出领域模型的应用")]),t._v(" "),a("li",[t._v("查询侧：引入查询总线对查询请求进行路由；请求链路一般直接连接到存储层，实现不同的定制化查询需求")])])])}),[],!1,null,null,null);a.default=v.exports}}]);