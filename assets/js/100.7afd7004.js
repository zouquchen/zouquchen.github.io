(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{421:function(_,v,t){"use strict";t.r(v);var e=t(8),r=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"mysql锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql锁"}},[_._v("#")]),_._v(" MySQL锁")]),_._v(" "),v("p",[_._v("MySQL 常见的锁：行锁、表锁、共享锁、排他锁、意向锁...")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-intention-locks",target:"_blank",rel:"noopener noreferrer"}},[_._v("MySQL InnoDB Locking"),v("OutboundLink")],1)]),_._v(" "),v("p",[_._v("参考："),v("a",{attrs:{href:"https://www.nowcoder.com/discuss/809140",target:"_blank",rel:"noopener noreferrer"}},[_._v("面试必会系列之MySQL锁相关内容"),v("OutboundLink")],1)]),_._v(" "),v("h2",{attrs:{id:"_1-锁的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-锁的分类"}},[_._v("#")]),_._v(" 1 锁的分类")]),_._v(" "),v("ul",[v("li",[_._v("共享锁（shared lock，S锁）：假设事务 T1 对数据 A 加上共享锁，那么事务  T2  可以读数据 A，不能修改数据 A。")]),_._v(" "),v("li",[_._v("排他锁（exclusive lock，X锁）：假设事务 T1 对数据 A 加上排他锁，那么事务 T2 不能读取数据 A，不能修改数据 A。")])]),_._v(" "),v("blockquote",[v("p",[_._v("T1获取记录的 S 锁，之后 T2 也可以获得该记录的 S 锁。")]),_._v(" "),v("p",[_._v("T1获取记录的 X 锁，之后 T2 即不可以获得该记录的 X 锁，也不可以获得 S 锁，都会被阻塞，直到 T1 提交事务释放 X 锁。")])]),_._v(" "),v("ul",[v("li",[_._v("意向共享锁（intention shared lock，IS锁）：一个事务在获取（任何一行/或者全表）S 锁之前，一定会先在所在的"),v("strong",[_._v("表")]),_._v("上加 IS 锁。")]),_._v(" "),v("li",[_._v("意向排他锁（intention exclusive lock，IX锁）：一个事务在获取（任何一行/或者全表）X 锁之前，一定会先在所在的"),v("strong",[_._v("表")]),_._v("上加 IX 锁。")])]),_._v(" "),v("h2",{attrs:{id:"_2-意向锁存在的目的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-意向锁存在的目的"}},[_._v("#")]),_._v(" 2 意向锁存在的目的")]),_._v(" "),v("p",[_._v("假设事务 T1，用排他锁来锁住了表上的几条记录，那么此时表上存在意向排他锁。那么此时事务 T2 要进行 "),v("code",[_._v("LOCK TABLE ... WRITE")]),_._v(" 的表级别锁的请求，可以直接根据意向锁是否存在而判断是否有锁冲突，而不是去遍历所有的记录去查看有没有行级别的排他锁。")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th"),_._v(" "),v("th",[v("code",[_._v("X")])]),_._v(" "),v("th",[v("code",[_._v("IX")])]),_._v(" "),v("th",[v("code",[_._v("S")])]),_._v(" "),v("th",[v("code",[_._v("IS")])])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("code",[_._v("X")])]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Conflict")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("IX")])]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Compatible")]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Compatible")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("S")])]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Compatible")]),_._v(" "),v("td",[_._v("Compatible")])]),_._v(" "),v("tr",[v("td",[v("code",[_._v("IS")])]),_._v(" "),v("td",[_._v("Conflict")]),_._v(" "),v("td",[_._v("Compatible")]),_._v(" "),v("td",[_._v("Compatible")]),_._v(" "),v("td",[_._v("Compatible")])])])]),_._v(" "),v("h2",{attrs:{id:"_3-加锁的算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-加锁的算法"}},[_._v("#")]),_._v(" 3 加锁的算法")]),_._v(" "),v("p",[_._v("下面三种情况都是行级别的锁，因为它们都是针对某一数据行或者某一范围的间隙进行加锁。")]),_._v(" "),v("p",[_._v("⭐ "),v("strong",[_._v("Record Lock，记录锁")]),_._v("（行锁）")]),_._v(" "),v("p",[_._v("该锁是对索引记录进行加锁！行锁要锁在索引上。innodb一定存在聚簇索引，因此行锁会落到聚簇索引上。")]),_._v(" "),v("p",[_._v("例如，"),v("code",[_._v("SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE")]),_._v("会阻止其他事务插入、修改或删除 c1 = 10 这行的数据。")]),_._v(" "),v("p",[_._v("⭐ "),v("strong",[_._v("Gap Lock：间隙锁")])]),_._v(" "),v("p",[_._v("是对索引间隙加锁，间隙锁用于锁定一个范围，但不包含记录本身。它的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。"),v("em",[_._v("在 RU 和 RC 隔离级别下，不会使用间隙锁。在 RR 和 Serializable 隔离级别下会使用间隙锁")]),_._v("。")]),_._v(" "),v("p",[_._v("例如，"),v("code",[_._v("SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE")]),_._v("会阻止其他事务插入 c1 = 15 的行数据。")]),_._v(" "),v("p",[_._v("⭐ "),v("strong",[_._v("Next-Key Lock：临键锁")])]),_._v(" "),v("p",[_._v("是行锁 + 索引前面的间隙锁的结合。记住了，锁住的是索引的间隙！比如一个索引包含值，10，11，13 和 20。那么，间隙锁的范围如下")]),_._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("(negative infinity, 10]\n(10, 11]\n(11, 13]\n(13, 20]\n(20, positive infinity)\n")])]),_._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[_._v("1")]),v("br"),v("span",{staticClass:"line-number"},[_._v("2")]),v("br"),v("span",{staticClass:"line-number"},[_._v("3")]),v("br"),v("span",{staticClass:"line-number"},[_._v("4")]),v("br"),v("span",{staticClass:"line-number"},[_._v("5")]),v("br")])]),v("p",[_._v("对于最后一个间隔范围，索引锁住的是最大值之后的范围，也就是 (20, positive infinity)，postive infinity 并不是无穷大，而是一个高于记录中的任意数据的一个值。")]),_._v(" "),v("p",[_._v("InnoDB 通过临键锁解决幻读问题。")]),_._v(" "),v("h2",{attrs:{id:"_4-快照读和当前读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-快照读和当前读"}},[_._v("#")]),_._v(" 4 快照读和当前读")]),_._v(" "),v("p",[_._v("在 mysql 中 select 分为快照读和当前读。")]),_._v(" "),v("p",[v("strong",[_._v("快照读")]),_._v("：")]),_._v(" "),v("p",[v("code",[_._v("select * from table where id = ?;")]),_._v("：读的是数据库记录的快照版本，不加锁的。")]),_._v(" "),v("p",[v("strong",[_._v("当前读")]),_._v("（需要加锁）：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("select * from table where id = ? lock in share mode;")]),_._v("：会对读取数据加共享锁。")]),_._v(" "),v("li",[v("code",[_._v("select * from table where id = ? for update")]),_._v("：会对读取数据加排他锁。")]),_._v(" "),v("li",[v("code",[_._v("insert")])]),_._v(" "),v("li",[v("code",[_._v("update")])]),_._v(" "),v("li",[v("code",[_._v("delete")])])]),_._v(" "),v("h2",{attrs:{id:"_5-表级锁-or-行级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-表级锁-or-行级锁"}},[_._v("#")]),_._v(" 5 表级锁 or 行级锁")]),_._v(" "),v("p",[_._v("MyISAM 只支持表级锁；InnoDB 支持表级锁和行级锁。")]),_._v(" "),v("p",[v("strong",[_._v("表级锁")]),_._v("：MySQL 中锁定粒度最大的一种锁，是"),v("strong",[_._v("针对非索引字段加的锁")]),_._v("，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。")]),_._v(" "),v("p",[_._v("通过"),v("code",[_._v("LOCK TABLE ... READ")]),_._v("和"),v("code",[_._v("LOCK TABLE ... WRITE")]),_._v("能申请表级别锁。")]),_._v(" "),v("p",[v("strong",[_._v("行级锁")]),_._v("：MySQL 中锁定粒度最小的一种锁，是"),v("strong",[_._v("针对索引字段加的锁")]),_._v("，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。")]),_._v(" "),v("p",[_._v("InnoDB 的"),v("u",[_._v("行级锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁")]),_._v("。当我们执行 "),v("code",[_._v("UPDATE")]),_._v("、"),v("code",[_._v("DELETE")]),_._v(" 语句时，如果 "),v("code",[_._v("WHERE")]),_._v("条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。")]),_._v(" "),v("h2",{attrs:{id:"_6-表级锁-or-行级锁分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-表级锁-or-行级锁分析"}},[_._v("#")]),_._v(" 6 表级锁 or 行级锁分析")]),_._v(" "),v("p",[_._v("行级锁或表级锁，是由「隔离级别」「查询列的索引」「查询条件」共同决定的。")]),_._v(" "),v("ul",[v("li",[_._v("隔离级别：RC/RU，RR/Serialziable")]),_._v(" "),v("li",[_._v("查询列的索引：唯一索引，非唯一索引，无索引")]),_._v(" "),v("li",[_._v("查询条件：精确匹配（=），非精确匹配（>、 <、 like）")])]),_._v(" "),v("p",[v("a",{attrs:{href:"https://www.nowcoder.com/discuss/809140",target:"_blank",rel:"noopener noreferrer"}},[_._v("面试必会系列之MySQL锁相关内容"),v("OutboundLink")],1),_._v("中共讨论了 40 种情况，对其中「"),v("strong",[_._v("当前读")]),_._v("」进行简单的归纳：")]),_._v(" "),v("blockquote",[v("p",[_._v("注意：下面的查询都是当前读，需要加锁；而不是快照读。")])]),_._v(" "),v("p",[_._v("⭐ "),v("strong",[_._v("在 RC/RU 隔离级别下的当前读")])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("隔离级别")]),_._v(" "),v("th",[_._v("查询列索引")]),_._v(" "),v("th",[_._v("查询条件")]),_._v(" "),v("th",[_._v("锁")]),_._v(" "),v("th",[_._v("锁的位置")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("RC/RU")]),_._v(" "),v("td",[_._v("无索引")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("记录锁")]),_._v(" "),v("td",[_._v("聚簇索引")])]),_._v(" "),v("tr",[v("td",[_._v("RC/RU")]),_._v(" "),v("td",[_._v("唯一索引")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("记录锁")]),_._v(" "),v("td",[_._v("唯一索引和聚簇索引")])]),_._v(" "),v("tr",[v("td",[_._v("RC/RU")]),_._v(" "),v("td",[_._v("非唯一索引")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("记录锁")]),_._v(" "),v("td",[_._v("聚簇索引")])])])]),_._v(" "),v("p",[_._v("当唯一索引为聚簇索引时，那么记录锁只加在聚簇索引上；当唯一索引非聚簇索引时，记录锁分别加在该唯一索引和聚簇索引上。")]),_._v(" "),v("p",[_._v("⭐ "),v("strong",[_._v("在 RR/Serializable 默认隔离级别下的当前读")])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("隔离级别")]),_._v(" "),v("th",[_._v("查询列索引")]),_._v(" "),v("th",[_._v("查询条件")]),_._v(" "),v("th",[_._v("锁")]),_._v(" "),v("th",[_._v("锁的位置")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("RR/Serializable")]),_._v(" "),v("td",[_._v("唯一索引")]),_._v(" "),v("td",[_._v("精确匹配(=)")]),_._v(" "),v("td",[_._v("记录锁")]),_._v(" "),v("td",[_._v("唯一索引和聚簇索引")])]),_._v(" "),v("tr",[v("td",[_._v("RR/Serializable")]),_._v(" "),v("td",[_._v("唯一索引")]),_._v(" "),v("td",[_._v("非精确匹配")]),_._v(" "),v("td",[_._v("记录锁 + 间隙锁")]),_._v(" "),v("td",[_._v("唯一索引，唯一索引的间隙")])]),_._v(" "),v("tr",[v("td",[_._v("RR/Serializable")]),_._v(" "),v("td",[_._v("非唯一索引")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("记录锁 + 间隙锁")]),_._v(" "),v("td",[_._v("聚簇索引，非唯一索引，非唯一索引的间隙")])]),_._v(" "),v("tr",[v("td",[_._v("RR/Serializable")]),_._v(" "),v("td",[_._v("无索引")]),_._v(" "),v("td"),_._v(" "),v("td",[_._v("表级锁")]),_._v(" "),v("td",[_._v("整表")])])])]),_._v(" "),v("p",[_._v("当查询条件为非唯一索引时，如：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("pId(int)")]),_._v(" "),v("th",[_._v("name(varchar)")]),_._v(" "),v("th",[_._v("num(int)")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("1")]),_._v(" "),v("td",[_._v("aaa")]),_._v(" "),v("td",[_._v("100")])]),_._v(" "),v("tr",[v("td",[_._v("2")]),_._v(" "),v("td",[_._v("bbb")]),_._v(" "),v("td",[_._v("200")])]),_._v(" "),v("tr",[v("td",[_._v("3")]),_._v(" "),v("td",[_._v("bbb")]),_._v(" "),v("td",[_._v("300")])]),_._v(" "),v("tr",[v("td",[_._v("7")]),_._v(" "),v("td",[_._v("ccc")]),_._v(" "),v("td",[_._v("200")])])])]),_._v(" "),v("p",[v("code",[_._v("select * from table where num = 200 lock in share mode")])]),_._v(" "),v("p",[_._v("在 pId=2，7 的聚簇索引上加 S 锁，在 num=200 的非聚集索引上加 S 锁，在 (100,200) (200,300) 加上 gap lock。")]),_._v(" "),v("p",[v("code",[_._v("select * from table where num > 200 lock in share mode")])]),_._v(" "),v("p",[_._v("在 pId=3 的聚簇索引上加 S 锁，在 num=300 的非聚集索引上加 S 锁。在 (200,300) (300,+∞) 加上 gap lock。")]),_._v(" "),v("h2",{attrs:{id:"_7-死锁的产生及解决策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-死锁的产生及解决策略"}},[_._v("#")]),_._v(" 7 死锁的产生及解决策略")]),_._v(" "),v("p",[v("strong",[_._v("死锁")]),_._v("：两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的线程，若无外力作用，它们都无法推进下去。")]),_._v(" "),v("p",[v("strong",[_._v("系统解决策略")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("直接进入等待，直到超时。整个超时时间可以通过参数 "),v("code",[_._v("innodb_lock_wait_timeou")]),_._v("来设置，默认为 50s。")]),_._v(" "),v("li",[_._v("发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务的以继续执行。"),v("code",[_._v("innodb_deadlock_detect")]),_._v("的默认值本身就是 on。")])]),_._v(" "),v("p",[v("strong",[_._v("人工解决策略")]),_._v("：")]),_._v(" "),v("ol",[v("li",[_._v("终止系统中的一个或多个死锁进程，打破循环。"),v("code",[_._v("kill 12345(进程Id);")])]),_._v(" "),v("li",[_._v("抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，打破死锁状态。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);